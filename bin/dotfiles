#!/usr/bin/env bash

# Variables
# ========================================================

# Dotfiles directory (With default value if first install)
[[ -d "$DOTFILES_PATH"  ]] && DOTFILES_DIR="$(readlink -e "$(dirname "$0")/..")" || DOTFILES_DIR="$HOME/.dotfiles"

BASH_COMPLETION_DIR="/etc/bash_completion.d"
BACKUP_DIR="$DOTFILES_DIR/backup"
I3_CONFIG_FILE="$HOME/.i3/config"
SSHRC_CONFIG_FILE="$HOME/.sshrc"

# Colors
_TXTCOLOR_RED=$(tput setaf 1)
_TXTCOLOR_GREEN=$(tput setaf 2)
_TXTCOLOR_YELLOW=$(tput setaf 3)
_TXTCOLOR_BLUE=$(tput setaf 4)
# _TXTCOLOR_MAGENTA=$(tput setaf 5)
# _TXTCOLOR_CYAN=$(tput setaf 6)
_TXTCOLOR_RESET=$(tput sgr0)

# Functions
# ========================================================

# Echos
# --------------------------------------------------------
echo_header() {   echo -e "\n${_TXTCOLOR_BLUE}⦿ $@${_TXTCOLOR_RESET}"; }
echo_error()  {   echo "    ${_TXTCOLOR_RED}✖${_TXTCOLOR_RESET} $@"; }

# Echos with alignment
# --------------------------------------------------------
print_success() {  printf "    ${_TXTCOLOR_GREEN}✔${_TXTCOLOR_RESET} %-20s %s \n" "$1" "${*:2}"; }
print_info()    {  printf "    ${_TXTCOLOR_BLUE}➤${_TXTCOLOR_RESET} %-20s %s \n" "$1" "${*:2}"; }
print_warning() {  printf "    ${_TXTCOLOR_YELLOW}⚠${_TXTCOLOR_RESET} %-20s %s \n" "$1" "${*:2}"; }

# Make a symlink (backup if destination exist)
# -------------------------------------------------------
make_symlink() {
	local dot_file_path="$1"
	local file_path="$2"
	local file_name=$(basename "$file_path")

	# With sudo ?
	[[ "$3" == "sudo"  ]] && local with_sudo="sudo " || with_sudo=""

	if [[ ! -d "$BACKUP_DIR" ]]; then
		echo_error "Backup directory $BACKUP_DIR doesn\'t exist"
		exit 2
	fi

	# If file_path is not already a symlink or doesn't exist
	if [[ ! -L "$file_path" ]]; then

		# File or directory already exist, make backup
		if [[ -f "$file_path" ]] || [[ -d "$file_path" ]]; then
			print_warning "$file_name" "Backup in $BACKUP_DIR/$file_name.bak"
			${with_sudo} mv "$file_path" "$BACKUP_DIR/$file_name.bak"
		fi

		# Make symlink
		print_success "$file_name" "symlink ➜ $file_path"
		${with_sudo} ln -s --force "$dot_file_path" "$file_path"
	else
		print_info "$file_name" "already installed"
	fi
}

# Create directory if necessary
# --------------------------------------------------------
dir_check() {
	local dir_path="$1"
	if [[ ! -d "$dir_path" ]]; then
		mkdir -p "$dir_path"
	fi
}

# Clone if doesn't exist, else update
# --------------------------------------------------------
clone_or_update() {
	local git_url="$1"
	local install_path="$2"
	local depot_name=$(basename "$install_path")

	if [[ -d "$install_path" ]]; then
		# Update if folder older than 7 day
		if file_is_fresh "$install_path" ; then
			print_info "$depot_name" "updated recently"
		else
			print_info "$depot_name" "update"
			( cd "$install_path" && git pull --quiet origin master )
		fi
	else
		# Clone
		print_success "$depot_name" "install"
		git clone --quiet "$git_url" "$install_path"
	fi
}

# Check if file is older than x days (default 7)
# --------------------------------------------------------
file_is_fresh() {
	local file="$1"
	local agemax=$((${2:-7} * 60 * 60 * 24))

	if [[ -e "$file" ]]; then
		local agefile=$(($(date +%s) - $(stat -c '%Y' "$file")))
		if [[ "$agefile" -lt "$agemax" ]]; then
			return 0
		fi
	fi

	return 1
}

# Install
# ========================================================

# Requirements
# --------------------------------------------------------
if [[ ! -x "$(which git 2>/dev/null)" ]]; then
	echo_error "Git is missing. Aborting."
	exit 1
fi

# Clone or update dotfiles
# --------------------------------------------------------
if [[ "$1" == "scriptrestart" ]]; then
	echo_header "Dotfiles updated"
else
	echo_header "Dotfiles"
fi

if [[ ! -d "$DOTFILES_DIR" ]]; then
	# $DOTFILES_DIR directory doesn't exist? Clone it!
	print_success "Dotfiles" "install"
	git clone --quiet "https://github.com/Silvus/dotfiles.git" $DOTFILES_DIR
elif [[ "$1" != "scriptrestart" ]]; then
	# Make sure we have the latest files
	print_info "Dotfiles" "update"
	prev_head="$(cd "$DOTFILES_DIR" && git rev-parse HEAD)"
	( cd "$DOTFILES_DIR" && git pull --quiet origin master )
	if [[ "$(cd "$DOTFILES_DIR" && git rev-parse HEAD)" != "$prev_head" ]]; then
		# Need a restart
		print_success "Dotfiles" "updated, restarting script"
		exec "$0" "scriptrestart"
	fi
fi

# Make symlinks for all "app" et "appdesktop" folders
# --------------------------------------------------------
echo_header "Symlinks apps"
"${DOTFILES_DIR}/bin/dotfiles_symlink"

# Download files from dotconf
# --------------------------------------------------------
echo_header "Download apps"
"${DOTFILES_DIR}/bin/dotfiles_download"

# Bash
# --------------------------------------------------------
echo_header "Bash"
dir_check "$HOME/bin"
make_symlink "$DOTFILES_DIR/bash/bash_aliases" "$HOME/.bash_aliases"

# Completions
# --------------------------------------------------------
make_symlink "$DOTFILES_DIR/bash/completion/tmux" "$BASH_COMPLETION_DIR/tmux" "sudo"
make_symlink "$DOTFILES_DIR/bash/completion/dev" "$BASH_COMPLETION_DIR/dev" "sudo"
make_symlink "$DOTFILES_DIR/bash/completion/go" "$BASH_COMPLETION_DIR/go" "sudo"
make_symlink "$DOTFILES_DIR/bash/completion/sshrc" "$BASH_COMPLETION_DIR/sshrc" "sudo"
make_symlink "$DOTFILES_DIR/bash/completion/composer" "$BASH_COMPLETION_DIR/composer" "sudo"

# Vim
# --------------------------------------------------------
dir_check "$HOME/.vim/backup"
dir_check "$HOME/.vim/swap"
dir_check "$HOME/.vim/undo"
dir_check "$HOME/.vim/autoload"
dir_check "$HOME/.vim/bundle"

# SSHRC
# --------------------------------------------------------
echo_header "SSHRC"

# Generated sshrc config
print_success "sshrc config" "generated"
echo -e "# DO NOT EDIT THIS FILE BY HAND.\n# YOUR CHANGES WILL BE OVERWRITTEN !\n" > "$SSHRC_CONFIG_FILE"
cat "$DOTFILES_DIR/sshrc/sshrc_main" >> "$SSHRC_CONFIG_FILE"
cat "$DOTFILES_DIR/bash/aliases/01_main.bash" >> "$SSHRC_CONFIG_FILE"
cat "$DOTFILES_DIR/bash/aliases/04_prompt.bash" >> "$SSHRC_CONFIG_FILE"
cat "$DOTFILES_DIR/sshrc/sshrc_ascii" >> "$SSHRC_CONFIG_FILE"

# Fzf
# --------------------------------------------------------
echo_header "Fzf"
if [[ ! -d "$HOME/.fzf" ]]; then
	clone_or_update "https://github.com/junegunn/fzf.git" "$HOME/.fzf"
	"$HOME/.fzf/install"
else
	clone_or_update "https://github.com/junegunn/fzf.git" "$HOME/.fzf"
fi

# MOC
# --------------------------------------------------------
if [[ -x "$(which mocp 2>/dev/null)" ]]; then
	echo_header "MOC"
	chmod 644 "$HOME/.moc/config" # Need to be not writable by other
fi

# i3
# --------------------------------------------------------
if [[ -x "$(which i3 2>/dev/null)" ]]; then
	echo_header "i3"
	dir_check "$HOME/.i3"

	make_symlink "$DOTFILES_DIR/i3/conky_launcher" "$HOME/.i3/conky_launcher"
	chmod 770 "$HOME/.i3/conky_launcher"
	make_symlink "$DOTFILES_DIR/i3/conky_statusbar" "$HOME/.i3/conky_statusbar"

	# Generated i3 config
	SCREEN_COUNT=$(xrandr -q | grep ' connected' | wc -l)
	print_success "i3 config" "generated (screens : $SCREEN_COUNT)"

	echo -e "# DO NOT EDIT THIS FILE BY HAND.\n# YOUR CHANGES WILL BE OVERWRITTEN !\n" > "$I3_CONFIG_FILE"
	cat "$DOTFILES_DIR/i3/config_main" >> "$I3_CONFIG_FILE"

	make_symlink "$DOTFILES_DIR/i3/i3status.conf" "$HOME/.i3/i3status.conf"

	if [[ "$SCREEN_COUNT" -gt 1 ]]; then
		# Dual screen
		cat "$DOTFILES_DIR/i3/config_bar_dual" >> "$I3_CONFIG_FILE"
	else
		# Simple screen
		cat "$DOTFILES_DIR/i3/config_bar" >> "$I3_CONFIG_FILE"
	fi

	cat "$DOTFILES_DIR/i3/config_apps" >> "$I3_CONFIG_FILE"
fi

# Virtualenvwrapper
# --------------------------------------------------------
if [[ -d "/data/dev/.virtualenvs" ]]; then
	echo_header "Virtualenv Hooks"
	make_symlink "$DOTFILES_DIR/virtualenvs/postactivate" "/data/dev/.virtualenvs/postactivate"
fi

# End
# --------------------------------------------------------
echo_header "End"
exit 0
