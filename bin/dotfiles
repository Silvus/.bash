#!/usr/bin/env python3
"""
Setup dotfiles
"""

import os
import sys
import time
import errno
import socket
import configparser
import fileinput
import argparse
from urllib.request import Request, urlretrieve
from urllib.error import URLError, HTTPError
from subprocess import Popen, PIPE, call

try:
    import pip
except ImportError:
    pip_is_installed = False
else:
    pip_is_installed = True

#####################################################################
# Prints (with colors)
#####################################################################

COLOR_RESET = '\033[0m'
COLOR_RED = '\033[31m'
COLOR_GREEN = '\033[32m'
COLOR_YELLOW = '\033[33m'
COLOR_BLUE = '\033[34m'


def print_header(message):
    print('\n' + COLOR_BLUE + '⦿ ' + COLOR_RESET + message)


def print_success(message):
    print(COLOR_GREEN + '    ✔ ' + COLOR_RESET + message)


def print_info(message):
    print(COLOR_BLUE + '    ➤ ' + COLOR_RESET + message)


def print_warning(message):
    print(COLOR_YELLOW + '    ⚠ ' + COLOR_RESET + message)


def print_error(message):
    print(COLOR_RED + '    ✖ ' + COLOR_RESET + message)


def print_question(question):
    return input('\n' + COLOR_YELLOW + '➜ ' + COLOR_RESET + question + ' ')

#####################################################################
# Helpers
#####################################################################


def assure_dir_exist(path):
    """ Create parents folders """
    dir = os.path.dirname(os.path.expanduser(path))
    if not os.path.exists(dir):
        os.makedirs(dir)


def exec_command(command, show_errors=True):
    """ Execute a system command """
    p = Popen(command, stdout=PIPE, stderr=PIPE)
    output, errors = p.communicate()

    if p.returncode != 0 and show_errors:
        print_error(errors.decode('UTF-8'))

    return p.returncode == 0


def is_installed(prog):
    """ Check if a program is installed """
    p = Popen(['which', prog], stdout=PIPE, stderr=PIPE)
    command_path, errors = p.communicate()

    return len(command_path) > 0


def check_requirements():
    """
    Exit if git isn't installed or Github isn't reachable
    """
    # Need git
    if not is_installed('git'):
        print_error('Git is missing. Aborting.')
        sys.exit(1)

    # Github access
    try:
        # DNS listening
        host = socket.gethostbyname('github.com')
        # Host is actually reachable
        socket.create_connection((host, 80), 2)
    except:
        print_error('Github can\'t be reach')
        sys.exit(2)


def X_is_running():
    return exec_command(["xset", "-q"], False)

#####################################################################
# Symlinks
#####################################################################


def symlink_arbo(rootSource, rootDestination, with_sudo=False):
    """
    Scan "app" directory and create an equivalent symlink
    in home for each file.
    If X is running, scan also "appdesktop"
    """
    for dirName, subdirList, fileList in os.walk(rootSource):
        for fileName in fileList:
            # Get relative dir from dotfiles root
            relativeDir = os.path.relpath(dirName, rootSource)
            # Add file name and handle "." (with normpath)
            relativeFile = os.path.normpath(os.path.join(relativeDir,
                                                         fileName))

            # Create absolutes paths
            source = os.path.join(rootSource, relativeFile)
            destination = os.path.join(rootDestination, relativeFile)

            if with_sudo:
                if not symlink_root(source, destination):
                    return False
            else:
                if not symlink(source, destination):
                    return False

    return True


def symlink(src, dest):
    """
    Make a symlink
    """
    # Remove existing symlink
    if os.path.lexists(dest):
        os.remove(dest)
    # Check if source exist
    if os.path.exists(src):
        # Create directories if necessary
        assure_dir_exist(dest)
        # Make symlink
        os.symlink(src, dest)
        print_success('➜ ' + os.path.relpath(dest, os.path.expanduser('~')))
        return True
    else:
        print_error(src + " doesn't exist")
        return False


def symlink_root(src, dest):
    """
    Make a symlink with sudo (no update if it already exists)
    """
    # Check if source exist
    if os.path.exists(src):
        # Check if destination already exist
        if os.path.exists(dest):
            print_info('Symlink (sudo) exist: ' + os.path.basename(dest))
            return True
        # Create directories if necessary
        assure_dir_exist(dest)
        # Make symlink
        print_success('➜ ' + dest)
        return exec_command(['sudo', 'ln', '-s', src, dest])
    else:
        print_error(src + " doesn't exist")
        return False

#####################################################################
# Directories
#####################################################################


def directories_create(directories):
    for dir_path, _ in directories:
        try:
            os.makedirs(os.path.expanduser(dir_path))
        except OSError as exc:
            if exc.errno != errno.EEXIST:
                raise exc
            pass

#####################################################################
# Downloads
#####################################################################


def download_install(apps):
    """
    Download each app in config file
    """
    for destination, url in apps:
        download(url, os.path.expanduser(destination))


def download(url, destination):
    """
    Check url status and download file
    Download file and set executable permission
    Only if file is older than 7 days and url HTTP code is ok
    """
    # Create parents folders
    assure_dir_exist(destination)

    if download_needed(destination):
        Request(url)
        try:
            urlretrieve(url, destination, reporthook=download_report)
        except HTTPError as e:
            print_warning(url + ' unavailable. Error code: ' + e.code)
        except URLError as e:
            print_warning(url + ' unavailable. Reason: ' + e.reason)
        else:
            # everything is fine
            os.chmod(destination, 0o755)
            sys.stdout.flush()
            sys.stdout.write("\r" + COLOR_GREEN + "    ✔ " + COLOR_RESET +
                             "Download complete: %s" % os.path.basename(
                                 destination) + '\n')
    else:
        print_info('Already present: ' + os.path.basename(destination))


def download_needed(path):
    """ Check if destination exist and is older than 7 days """
    if os.path.isfile(path):
        # File exist, check his age
        now = time.time()
        limit = 60 * 60 * 24 * 7  # Number of seconds in 7 days
        return os.stat(path).st_mtime < now - limit
    else:
        # File doesn't exist
        return True


def download_report(count, blockSize, totalSize):
    """ Report download status in percentage """
    percent = int(count * blockSize * 100 / totalSize)
    sys.stdout.write("\r%d%%" % percent + ' complete')
    sys.stdout.flush()

#####################################################################
# Pip
#####################################################################


def pip_install(packages):
    """
    Check if pip and pipsi are installed and call the corresponding function
    """
    if pip_is_installed:
        if is_installed('pipsi'):
            pip_install_packages_pipsi(packages)
        else:
            pip_install_packages(packages)
    else:
        print_error('pip is not installed')


def pip_install_packages(packages):
    """
    Download packages list with pip
    """
    os.environ['PIP_REQUIRE_VIRTUALENV'] = ''
    for package, _ in packages:
        print_info('pip: ' + package)
        pip.main(['install', '--user', '--upgrade', '--quiet', package])


def pip_install_packages_pipsi(packages):
    """
    Use pipsi (pip in virtualenv) instead of pip
    """
    for package, _ in packages:
        print_info('pipsi: ' + package)

        pipsi_venv_path = os.path.join(
            os.path.expanduser(os.getenv('PIPSI_HOME', '~/.local/venvs')),
            package)
        if os.path.isdir(pipsi_venv_path):
            # Package already present, upgrade
            call(['pipsi', 'upgrade', package])
        else:
            # Install
            call(['pipsi', 'install', package])

#####################################################################
# Apt
#####################################################################


def apt_install_packages(packages_server=None, packages_desktop=None):
    """
    Merge server et desktop packages lists and install them
    """
    apt_package_list = []
    if packages_server:
        for apt_package, _ in packages_server:
            apt_package_list.append(apt_package)

    if packages_desktop and X_is_running():
        for apt_package, _ in packages_desktop:
            apt_package_list.append(apt_package)

    if len(apt_package_list) > 0:
        # Update
        print_info('Update')
        call(['sudo', 'apt-get', '-qq', 'update'])
        # Upgrade
        print_info('Upgrade')
        call(['sudo', 'apt-get', 'dist-upgrade'])
        # Install
        print_info('Install ' + ', '.join(apt_package_list))
        call(['sudo', 'apt-get', 'install'] + apt_package_list)

#####################################################################
# Compile
#####################################################################


def generate_config(outfilename, filenames):
    """ Generate config from multiple files """
    with open(outfilename, 'w') as fout:
        fout.write(
            '# DO NOT EDIT THIS FILE BY HAND.\n# YOUR CHANGES WILL BE OVERWRITTEN !\n\n')
        for line in fileinput.input(filenames):
            fout.write(line)
    print_success('Generated: ' + outfilename)

#####################################################################
# Git
#####################################################################


def git_clone(url, destination):
    print_info('Clone ' + destination)
    return exec_command(['git', 'clone', url, destination])


def git_pull(destination):
    print_info('Update ' + destination)
    return exec_command(['git', '--work-tree=' + destination, '--git-dir=' +
                         destination + '/.git', 'pull', 'origin', 'master'])


def git_version(destination):
    """ Get current commit """
    p = Popen(
        ['git', '--work-tree=' + destination,
         '--git-dir=' + destination + '/.git', 'rev-parse', 'HEAD'],
        stdout=PIPE,
        stderr=PIPE)
    version, errors = p.communicate()
    if p.returncode != 0:
        print_error(errors.decode('UTF-8'))
        return False
    else:
        return version


def git_clone_or_update(items):
    """
    Update if destination exist, else clone with git
    """
    for destination, url in items:
        destination = os.path.expanduser(destination)
        if os.path.exists(destination):
            git_pull(destination)
        else:
            git_clone(url, destination)


def git_clone_or_update_dotfiles(dotfilesurl, dotfilespath, restarted=False):
    """ Clone or update dotfiles """
    print_header('Dotfiles updated' if restarted else 'Dotfiles')

    if not os.path.exists(dotfilespath):
        # dotfiles directory doesn't exist? Clone it
        git_clone(dotfilesurl, dotfilespath)

    else:
        # Get current commit
        dot_version_prev = git_version(dotfilespath)

        # Update
        git_pull(dotfilespath)

        # Get current commit
        dot_version_next = git_version(dotfilespath)

        if dot_version_prev != dot_version_next:
            # Restart current script if version change
            os.execl(sys.executable, sys.executable, sys.argv[0], '--restart',
                     *sys.argv[1:])

#####################################################################
# Dependencies
#####################################################################


def install_dependencies(config_file):
    """ Read the config file and execute each section """
    # Check for config file
    if os.path.isfile(config_file):
        # Read conf
        config = configparser.ConfigParser(allow_no_value=True)
        config.read(config_file)

        # Assure each directory in "directories" section exist
        if config.has_section('directories'):
            directories_create(config.items('directories'))

        # Download each item in "download" section
        if config.has_section('download'):
            download_install(config.items('download'))

        # Clone each item in "clone" section
        if config.has_section('clone'):
            git_clone_or_update(config.items('clone'))

        # Install from pip if it's present
        if config.has_section('pip'):
            pip_install(config.items('pip'))

        # Install with apt
        if config.has_section('apt_server') or config.has_section(
                'apt_desktop'):
            print_header('Apt')
            apt_install_packages(
                packages_server=config.items('apt_server')
                if config.has_section('apt_server') else None,
                packages_desktop=config.items('apt_desktop') if
                config.has_section('apt_desktop') else None)

    else:
        # Config not found
        print_error("Config file " + config_file + " doesn't exist")
        sys.exit(1)

#####################################################################
# Main
#####################################################################

if __name__ == '__main__':

    # Read arguments
    parser = argparse.ArgumentParser(prog='dotfiles')
    parser.add_argument("-p",
                        "--path",
                        help="Dotfiles base path. Default ~/.dotfiles",
                        default=os.path.expanduser('~/.dotfiles'))
    parser.add_argument("-d",
                        "--dependencies",
                        help="Install or upgrade dependencies",
                        action="store_true",
                        default=False)
    parser.add_argument("-r",
                        "--restart",
                        help=argparse.SUPPRESS,
                        action="store_true",
                        default=False)

    args = parser.parse_args()

    dotfilespath = args.path
    restarted = args.restart
    with_dependencies = args.dependencies

    # Requirements
    check_requirements()

    # Self update
    git_clone_or_update_dotfiles('https://github.com/Silvus/dotfiles.git',
                                 dotfilespath, restarted)

    # Install apps if argument
    if with_dependencies:
        # Install from config file
        print_header('Download apps')
        config_file = dotfilespath + '/dotconf'
        install_dependencies(config_file)

    # Make symlinks
    print_header('Symlinks apps')
    if symlink_arbo(dotfilespath + '/app', os.path.expanduser('~')):

        print_header('Symlinks root apps')
        symlink_arbo(dotfilespath + '/approot', '/', True)

        if X_is_running():
            print_header('Symlinks desktop apps')
            symlink_arbo(dotfilespath + '/appdesktop', os.path.expanduser('~'))

    # Compile sshrc config
    print_header('Sshrc')
    generate_config(
        os.path.expanduser("~/.sshrc"), [
            dotfilespath + '/sshrc/sshrc_main',
            dotfilespath + '/bash/aliases/01_main.bash',
            dotfilespath + '/bash/aliases/04_prompt.bash',
            dotfilespath + '/sshrc/sshrc_ascii',
        ])

    sys.exit(0)
