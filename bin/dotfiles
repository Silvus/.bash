#!/usr/bin/env python3
"""
Setup dotfiles
"""

import os
import sys
import time
import configparser
import fileinput
import argparse
from urllib.request import Request, urlretrieve
from urllib.error import URLError, HTTPError
from subprocess import Popen, PIPE, call

try:
    import pip
except ImportError:
    pip_is_installed = False
else:
    pip_is_installed = True

#####################################################################
# Prints (with colors)
#####################################################################

COLOR_RESET = '\033[0m'
COLOR_RED = '\033[31m'
COLOR_GREEN = '\033[32m'
COLOR_YELLOW = '\033[33m'
COLOR_BLUE = '\033[34m'


def print_header(message):
    print('\n' + COLOR_BLUE + '⦿ ' + COLOR_RESET + message)


def print_success(message):
    print(COLOR_GREEN + '    ✔ ' + COLOR_RESET + message)


def print_info(message):
    print(COLOR_BLUE + '    ➤ ' + COLOR_RESET + message)


def print_warning(message):
    print(COLOR_YELLOW + '    ⚠ ' + COLOR_RESET + message)


def print_error(message):
    print(COLOR_RED + '    ✖ ' + COLOR_RESET + message)


def print_question(question):
    return input('\n' + COLOR_YELLOW + '➜ ' + COLOR_RESET + question + ' ')

#####################################################################
# Helpers
#####################################################################


def assure_dir_exist(path):
    """ Create parents folders """
    dir = os.path.dirname(os.path.expanduser(path))
    if not os.path.exists(dir):
        os.makedirs(dir)


def exec_command(command, show_errors=True):
    """ Execute a system command """
    p = Popen(command, stdout=PIPE, stderr=PIPE)
    output, errors = p.communicate()

    if p.returncode != 0 and show_errors:
        print_error(errors.decode('UTF-8'))

    return p.returncode == 0


def is_installed(prog):
    """ Check if a program is installed """
    p = Popen(['which', prog], stdout=PIPE, stderr=PIPE)
    command_path, errors = p.communicate()

    return len(command_path) > 0


def check_requirements():
    if not is_installed('git'):
        print_error('Git is missing. Aborting.')
        sys.exit(1)


def X_is_running():
    return exec_command(["xset", "-q"], False)

#####################################################################
# Symlinks
#####################################################################


def symlink_arbo(rootSource, rootDestination, with_sudo=False):
    """
    Scan "app" directory and create an equivalent symlink
    in home for each file.
    If X is running, scan also "appdesktop"
    """
    for dirName, subdirList, fileList in os.walk(rootSource):
        for fileName in fileList:
            # Get relative dir from dotfiles root
            relativeDir = os.path.relpath(dirName, rootSource)
            # Add file name and handle "." (with normpath)
            relativeFile = os.path.normpath(os.path.join(relativeDir,
                                                         fileName))

            # Create absolutes paths
            source = os.path.join(rootSource, relativeFile)
            destination = os.path.join(rootDestination, relativeFile)

            if with_sudo:
                if not symlink_root(source, destination):
                    return False
            else:
                if not symlink(source, destination):
                    return False

    return True


def symlink(src, dest):
    """
    Make a symlink
    """
    # Remove existing symlink
    if os.path.lexists(dest):
        os.remove(dest)
    # Check if source exist
    if os.path.exists(src):
        # Create directories if necessary
        assure_dir_exist(dest)
        # Make symlink
        os.symlink(src, dest)
        print_success('➜ ' + os.path.relpath(dest, os.path.expanduser('~')))
        return True
    else:
        print_error(src + " doesn't exist")
        return False


def symlink_root(src, dest):
    """
    Make a symlink with sudo (no update if it already exists)
    """
    # Check if source exist
    if os.path.exists(src):
        # Check if destination already exist
        if os.path.exists(dest):
            print_info('Symlink (sudo) exist: ' + os.path.basename(dest))
            return True
        # Create directories if necessary
        assure_dir_exist(dest)
        # Make symlink
        print_success('➜ ' + dest)
        return exec_command(['sudo', 'ln', '-s', src, dest])
    else:
        print_error(src + " doesn't exist")
        return False

#####################################################################
# Downloads
#####################################################################


def download(url, destination):
    """
    Check url status and download file
    Download file and set executable permission
    Only if file is older than 7 days and url HTTP code is ok
    """
    # Create parents folders
    assure_dir_exist(destination)

    if need_to_download(destination):
        req = Request(url)
        try:
            urlretrieve(url, destination, reporthook=report_download)
        except HTTPError as e:
            print_warning(url + ' unavailable. Error code: ' + e.code)
        except URLError as e:
            print_warning(url + ' unavailable. Reason: ' + e.reason)
        else:
            # everything is fine
            os.chmod(destination, 0o755)
            sys.stdout.flush()
            sys.stdout.write("\r" + COLOR_GREEN + "    ✔ " + COLOR_RESET +
                             "Download complete: %s" % os.path.basename(
                                 destination) + '\n')
    else:
        print_info('Already present: ' + os.path.basename(destination))


def need_to_download(path):
    """ Check if destination exist and is older than 7 days """
    if os.path.isfile(path):
        # File exist, check his age
        now = time.time()
        limit = 60 * 60 * 24 * 7  # Number of seconds in 7 days
        return os.stat(path).st_mtime < now - limit
    else:
        # File doesn't exist
        return True


def report_download(count, blockSize, totalSize):
    """ Report download status in percentage """
    percent = int(count * blockSize * 100 / totalSize)
    sys.stdout.write("\r%d%%" % percent + ' complete')
    sys.stdout.flush()

#####################################################################
# Compile
#####################################################################


def generate_config(outfilename, filenames):
    """ Generate config from multiple files """
    with open(outfilename, 'w') as fout:
        fout.write(
            '# DO NOT EDIT THIS FILE BY HAND.\n# YOUR CHANGES WILL BE OVERWRITTEN !\n\n')
        for line in fileinput.input(filenames):
            fout.write(line)
    print_success('Generated: ' + outfilename)

#####################################################################
# Git
#####################################################################


def git_clone(url, destination):
    print_info('Clone ' + destination)
    return exec_command(['git', 'clone', url, destination])


def git_pull(destination):
    print_info('Update ' + destination)
    return exec_command(['git', '--work-tree=' + destination, '--git-dir=' +
                         destination + '/.git', 'pull', 'origin', 'master'])


def git_version(destination):
    """ Get current commit """
    p = Popen(
        ['git', '--work-tree=' + destination,
         '--git-dir=' + destination + '/.git', 'rev-parse', 'HEAD'],
        stdout=PIPE,
        stderr=PIPE)
    version, errors = p.communicate()
    if p.returncode != 0:
        print_error(errors.decode('UTF-8'))
        return False
    else:
        return version


def clone_or_update(url, destination):
    if os.path.exists(destination):
        git_pull(destination)
    else:
        git_clone(url, destination)


def clone_or_update_dotfiles(dotfilesurl, dotfilespath, restarted=False):
    """ Clone or update dotfiles """
    if restarted:
        print_header('Dotfiles updated')
    else:
        print_header('Dotfiles')

    if not os.path.exists(dotfilespath):
        # dotfiles directory doesn't exist? Clone it
        git_clone(dotfilesurl, dotfilespath)

    else:
        # Get current commit
        dot_version_prev = git_version(dotfilespath)

        # Update
        git_pull(dotfilespath)

        # Get current commit
        dot_version_next = git_version(dotfilespath)

        if dot_version_prev != dot_version_next:
            # Restart current script if version change
            os.execl(sys.executable, sys.executable, sys.argv[0], '--restart',
                     *sys.argv[2:])

#####################################################################
# Config
#####################################################################


def read_config(config_file):
    """ Read the config file and execute each section """
    # Check for config file
    if os.path.isfile(config_file):
        # Read conf
        config = configparser.ConfigParser(allow_no_value=True)
        config.read(config_file)

        # Assure each directory in "directories" section exist
        if config.has_section('directories'):
            for dir_path, _ in config.items('directories'):
                dir_path = os.path.expanduser(dir_path)
                if not os.path.exists(dir_path):
                    os.makedirs(dir_path)

        # Download each item in "download" section
        if config.has_section('download'):
            for destination, url in config.items('download'):
                download(url, os.path.expanduser(destination))

        # Clone each item in "clone" section
        if config.has_section('clone'):
            for destination, url in config.items('clone'):
                clone_or_update(url, os.path.expanduser(destination))

        # Install from pip if it's present
        if config.has_section('pip'):
            if pip_is_installed:
                os.environ['PIP_REQUIRE_VIRTUALENV'] = ''
                for package, _ in config.items('pip'):
                    print_info('pip: ' + package)
                    pip.main(['install', '--user', '--upgrade', '--quiet',
                              package])
            else:
                print_error('pip is not installed')

        # Install with apt
        apt_package_list = []
        if config.has_section('apt_server'):
            for apt_package, _ in config.items('apt_server'):
                apt_package_list.append(apt_package)

        if config.has_section('apt_desktop') and X_is_running():
            for apt_package, _ in config.items('apt_desktop'):
                apt_package_list.append(apt_package)

        if len(apt_package_list) > 0:
            print_header('Apt')
            # Update
            print_info('Update')
            call(['sudo', 'apt-get', 'update'])
            # Upgrade
            print_info('Upgrade')
            call(['sudo', 'apt-get', 'dist-upgrade'])
            # Install
            print_info('Install ' + ', '.join(apt_package_list))
            call(['sudo', 'apt-get', 'install'] + apt_package_list)

    else:
        # Config not found
        print_error("Config file " + config_file + " doesn't exist")
        sys.exit(1)

#####################################################################
# Main
#####################################################################

if __name__ == '__main__':

    # Read arguments
    parser = argparse.ArgumentParser(prog='dotfiles')
    parser.add_argument("-p",
                        "--path",
                        help="Dotfiles base path. Default ~/.dotfiles",
                        default=os.path.expanduser('~/.dotfiles'))
    parser.add_argument("-d",
                        "--dependencies",
                        help="Install or upgrade dependencies",
                        action="store_true",
                        default=False)
    parser.add_argument("-r",
                        "--restart",
                        help=argparse.SUPPRESS,
                        action="store_true",
                        default=False)

    args = parser.parse_args()

    dotfilespath = args.path
    restarted = args.restart
    install_dependencies = args.dependencies

    # Requirements
    check_requirements()

    # Self update
    clone_or_update_dotfiles('https://github.com/Silvus/dotfiles.git',
                             dotfilespath, restarted)

    # Install apps if argument
    if install_dependencies:
        # Install from config file
        print_header('Download apps')
        config_file = dotfilespath + '/dotconf'
        read_config(config_file)

    # Make symlinks
    print_header('Symlinks apps')
    if symlink_arbo(dotfilespath + '/app', os.path.expanduser('~')):

        print_header('Symlinks root apps')
        symlink_arbo(dotfilespath + '/approot', '/', True)

        if X_is_running():
            print_header('Symlinks desktop apps')
            symlink_arbo(dotfilespath + '/appdesktop', os.path.expanduser('~'))

    # Compile sshrc config
    print_header('Sshrc')
    generate_config(
        os.path.expanduser("~/.sshrc"), [
            dotfilespath + '/sshrc/sshrc_main',
            dotfilespath + '/bash/aliases/01_main.bash',
            dotfilespath + '/bash/aliases/04_prompt.bash',
            dotfilespath + '/sshrc/sshrc_ascii',
        ])

    sys.exit(0)
