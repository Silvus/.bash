#!/usr/bin/env python3
"""
Setup dotfiles
"""

import os
import sys
import socket
import fileinput
import argparse
from subprocess import Popen, PIPE

#####################################################################
# Prints (with colors)
#####################################################################

COLOR_RESET = '\033[0m'
COLOR_RED = '\033[31m'
COLOR_GREEN = '\033[32m'
COLOR_YELLOW = '\033[33m'
COLOR_BLUE = '\033[34m'


def print_header(message):
    print('\n' + COLOR_BLUE + '⦿ ' + COLOR_RESET + message)


def print_success(message):
    print(COLOR_GREEN + '    ✔ ' + COLOR_RESET + message)


def print_info(message):
    print(COLOR_BLUE + '    ➤ ' + COLOR_RESET + message)


def print_warning(message):
    print(COLOR_YELLOW + '    ⚠ ' + COLOR_RESET + message)


def print_error(message):
    print(COLOR_RED + '    ✖ ' + COLOR_RESET + message)


def print_question(question):
    return input('\n' + COLOR_YELLOW + '➜ ' + COLOR_RESET + question + ' ')

#####################################################################
# Helpers
#####################################################################


def assure_dir_exist(path):
    """ Create parents folders """
    dir_path = os.path.dirname(os.path.expanduser(path))
    if not os.path.exists(dir_path):
        try:
            os.makedirs(dir_path)
        except OSError as exc:
            print_error("{}".format(exc))


def exec_command(command, show_errors=True):
    """ Execute a system command """
    p = Popen(command, stdout=PIPE, stderr=PIPE)
    output, errors = p.communicate()

    if p.returncode != 0 and show_errors:
        print_error(errors.decode('UTF-8'))

    return p.returncode == 0


def is_installed(prog):
    """ Check if a program is installed """
    p = Popen(['which', prog], stdout=PIPE, stderr=PIPE)
    command_path, errors = p.communicate()

    return len(command_path) > 0


def check_requirements():
    """
    Exit if git isn't installed or Github isn't reachable
    """
    # Need git
    if not is_installed('git'):
        print_error('Git is missing. Aborting.')
        sys.exit(2)

    # Github access
    try:
        # DNS listening
        host = socket.gethostbyname('github.com')
        # Host is actually reachable
        socket.create_connection((host, 80), 2)
    except:
        print_error('Github can\'t be reach')
        sys.exit(3)


def X_is_running():
    """
    Try to guess if x is running
    """
    try:
        return exec_command(["xset", "-q"], False)
    except OSError:
        # If xset (user preference utility for X) doesn't exist, there is a FileNotFoundError
        return False


def is_hidpi():
    """
    Get screen width resolution. If it's looks big, return true
    """
    output = Popen('xrandr | grep "\*" | cut -d" " -f4', shell=True, stdout=PIPE, stderr=PIPE).communicate()
    resolution = output[0].decode('UTF-8').split()[0].split('x')
    width = int(resolution[0])
    height = int(resolution[1])
    return (width > 2600 and height > 1600)

#####################################################################
# Symlinks
#####################################################################


def symlink_arbo(rootSource, rootDestination, with_sudo=False):
    """
    Scan "app" directory and create an equivalent symlink
    in home for each file.
    If X is running, scan also "appdesktop"
    """
    for dirName, subdirList, fileList in os.walk(rootSource):
        for fileName in fileList:
            # Get relative dir from dotfiles root
            relativeDir = os.path.relpath(dirName, rootSource)
            # Add file name and handle "." (with normpath)
            relativeFile = os.path.normpath(os.path.join(relativeDir, fileName))

            # Create absolutes paths
            source = os.path.join(rootSource, relativeFile)
            destination = os.path.join(rootDestination, relativeFile)

            if with_sudo:
                if not symlink_root(source, destination):
                    return False
            else:
                if not symlink(source, destination):
                    return False

    return True


def symlink(src, dest):
    """
    Make a symlink
    """
    # Remove existing symlink
    if os.path.lexists(dest):
        os.remove(dest)
    # Check if source exist
    if os.path.exists(src):
        # Create directories if necessary
        assure_dir_exist(dest)
        # Make symlink
        os.symlink(src, dest)
        print_success('➜ ' + os.path.relpath(dest, os.path.expanduser('~')))
        return True
    else:
        print_error(src + " doesn't exist")
        return False


def symlink_root(src, dest):
    """
    Make a symlink with sudo (no update if it already exists)
    """
    # Check if source exist
    if os.path.exists(src):
        # Check if destination already exist
        if os.path.exists(dest):
            print_info('Symlink (sudo) exist: ' + os.path.basename(dest))
            return True
        # Create directories if necessary
        assure_dir_exist(dest)
        # Make symlink
        print_success('➜ ' + dest)
        return exec_command(['sudo', 'ln', '-s', src, dest])
    else:
        print_error(src + " doesn't exist")
        return False

#####################################################################
# Compile
#####################################################################


def generate_config(outfilename, filenames, comment='#'):
    """ Generate config from multiple files """
    with open(outfilename, 'w') as fout:
        fout.write('{0} DO NOT EDIT THIS FILE BY HAND.\n{0} YOUR CHANGES WILL BE OVERWRITTEN !\n\n'.format(comment))
        for line in fileinput.input(filenames):
            fout.write(line)
    print_success('Generated: ' + outfilename)

#####################################################################
# Git
#####################################################################


def git_clone(url, destination):
    print_info('Clone ' + destination)
    return exec_command(['git', 'clone', url, destination])


def git_pull(destination):
    print_info('Update ' + destination)
    return exec_command(['git', '--work-tree=' + destination, '--git-dir=' + destination + '/.git',
                         'pull', 'origin', 'master'])


def git_version(destination):
    """ Get current commit """
    p = Popen(
        ['git', '--work-tree=' + destination, '--git-dir=' + destination + '/.git', 'rev-parse',
         'HEAD'],
        stdout=PIPE,
        stderr=PIPE)
    version, errors = p.communicate()
    if p.returncode != 0:
        print_error(errors.decode('UTF-8'))
        return False
    else:
        return version


def git_clone_or_update_dotfiles(dotfilesurl, dotfilespath, restarted=False):
    """ Clone or update dotfiles """
    print_header('Dotfiles updated' if restarted else 'Dotfiles')

    if not os.path.exists(dotfilespath):
        # dotfiles directory doesn't exist? Clone it
        git_clone(dotfilesurl, dotfilespath)

    else:
        # Get current commit
        dot_version_prev = git_version(dotfilespath)

        # Update
        git_pull(dotfilespath)

        # Get current commit
        dot_version_next = git_version(dotfilespath)

        if dot_version_prev != dot_version_next:
            # Restart current script if version change
            os.execl(sys.executable, sys.executable, sys.argv[0], '--restart', *sys.argv[1:])

#####################################################################
# Main
#####################################################################

if __name__ == '__main__':

    # Read arguments
    parser = argparse.ArgumentParser(prog='dotfiles')
    parser.add_argument("-p",
                        "--path",
                        help="Dotfiles base path. Default ~/.dotfiles",
                        default=os.path.expanduser('~/.dotfiles'))
    parser.add_argument("-r",
                        "--restart",
                        help=argparse.SUPPRESS,
                        action="store_true",
                        default=False)

    args = parser.parse_args()

    dotfilespath = args.path
    restarted = args.restart

    try:
        # Requirements
        check_requirements()

        # Self update
        git_clone_or_update_dotfiles('https://github.com/Silvus/dotfiles.git', dotfilespath,
                                     restarted)

        # Make symlinks
        print_header('Symlinks apps')
        if symlink_arbo(os.path.join(dotfilespath, 'app'), os.path.expanduser('~')):

            print_header('Symlinks root apps')
            symlink_arbo(os.path.join(dotfilespath, 'approot'), '/', True)

            if X_is_running():
                print_header('Symlinks desktop apps')
                symlink_arbo(os.path.join(dotfilespath, 'appdesktop'), os.path.expanduser('~'))

                # Compile .Xresources
                if is_hidpi():
                    print_header('Xresources HiDPI')
                    xresources_xft = os.path.join(dotfilespath, 'shell/Xresources_xft_hidpi')
                else:
                    print_header('Xresources')
                    xresources_xft = os.path.join(dotfilespath, 'shell/Xresources_xft')
                generate_config(
                    os.path.expanduser("~/.Xresources"), [
                        xresources_xft,
                        os.path.join(dotfilespath, 'shell/Xresources'),
                    ], '!')
                exec_command(['xrdb', os.path.expanduser('~/.Xresources')])

        # Compile sshrc config
        print_header('Sshrc')
        generate_config(
            os.path.expanduser("~/.sshrc"), [
                os.path.join(dotfilespath, 'sshrc/sshrc_main'),
                os.path.join(dotfilespath, 'shell/aliases/01_main.sh'),
                os.path.join(dotfilespath, 'shell/bash/02_prompt.bash'),
                os.path.join(dotfilespath, 'sshrc/sshrc_ascii'),
            ])
    except KeyboardInterrupt:
        print_error('Aborting...')
        sys.exit(1)

    sys.exit(0)
